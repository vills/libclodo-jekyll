---
title: "Команды Linux"
description: "Команды Linux: расширенный cправочник команд Unix"
layout: article
category: Используем Linux
---

Большинство UNIX-like систем обладают встроенной справкой, которая подробно описывает все доступные команды. Однако чтобы воспользоваться этой справкой, вы должны знать, по крайней мере, название команды, о которой вы хотите получить информацию. Поскольку большинство пользователей только в общих чертах понимают, что они хотят сделать, то, как правило, встроенная справка мало полезна новичкам.

Этот справочник поможет пользователям, знающим, что они хотят сделать, найти соответствующую команду Linux по краткому описанию.

* t
{:toc}

## Системная информация

* отобразить архитектуру компьютера:


        arch

* отобразить используемую версию ядра

        uname -r

* показать аппаратные системные компоненты — (SMBIOS / DMI)

        dmidecode -q

* вывести характеристики жесткого диска

        hdparm -i /dev/hda

* отобразить информацию о процессоре

        cat /proc/cpuinfo

* показать прерывания

        cat /proc/interrupts

* проверить использование памяти

        cat /proc/meminfo

* показать файл(ы) подкачки

        cat /proc/swaps

* вывести версию ядра

        cat /proc/version

* показать сетевые интерфейсы и статистику по ним

        cat /proc/net/dev

* отобразить смонтированные файловые системы

        cat /proc/mounts

* показать в виде дерева PCI устройства

        lspci -tv

* показать в виде дерева USB устройства

        lsusb -tv

* вывести системную дату

        date

* вывести таблицу-календарь 2011-го года

        cal 2007

* установить системные дату и время ММДДЧЧммГГГГ.СС 

        date 041217002007.00*

* сохранить системное время в BIOS

        clock -w

## Остановка системы

* остановить систему

        shutdown -h

* запланировать остановку системы на указанное время

        shutdown -h hours:minutes &

* отменить запланированную по расписанию остановку системы

        shutdown -c

* перезагрузить систему

        shutdown -r

* выйти из системы

        logout

## Файлы и директории

* перейти в директорию '/home'

        cd /home

* перейти в директорию уровнем выше

        cd ..

* перейти в директорию двумя уровнями выше

        cd ../..

* перейти в домашнюю директорию

        cd

* перейти в домашнюю директорию пользователя user

        cd ~user

* перейти в директорию, в которой находились до перехода в текущую директорию

        cd -

* показать текущюю директорию

        pwd

* отобразить содержимое текущей директории

        ls

* отобразить содержимое текущей директории с добавлением к именам символов, храктеризующих тип

        ls -F

* показать детализированое представление файлов и директорий в текущей директории

        ls -l

* показать скрытые файлы и директории в текущей директории

        ls -a

* показать файлы и директории содержащие в имени цифры

        ls *[0-9]*

* показать дерево файлов и директорий, начиная от корня (/)

        tree

* создать директорию с именем 'dir1'

        mkdir dir1

* создать две директории одновременно

        mkdir dir1 dir2

* создать дерево директорий

        mkdir -p /tmp/dir1/dir2

* удалить файл с именем 'file1'

        rm -f file1

* удалить директорию с именем 'dir1'

        rmdir dir1

* удалить директорию с именем 'dir1' и рекурсивно всё её содержимое

        rm -rf dir1

* удалить две директории и рекурсивно их содержимое

        rm -rf dir1 dir2

* переименовать или переместить файл или директорию

        mv dir1 new_dir

* скопировать файл file1 в файл file2

        cp file1 file2

* копировать все файлы директории dir в текущую директорию

        cp dir/* .

* копировать директорию dir1 со всем содержимым в текущую директорию

        cp -a /tmp/dir1 .

* копировать директорию dir1 в директорию dir2

        cp -a dir1 dir2

* создать символическую ссылку на файл или директорию

        ln -s file1 lnk1*

* создать «жёсткую» (физическую) ссылку на файл или директорию

        ln file1 lnk1

* модифицировать дату и время создания файла, при его отсутствии, создать файл с указанными датой и временем (YYMMDDhhmm)

        touch -t 0712250000 fileditest

## Поиск файлов

* найти файлы и директории с именем file1. Поиск начать с корня (/)

        find / -name file1

* найти файл и директорию принадлежащие пользователю user1. Поиск начать с корня (/)

        find / -user user1

* найти все файлы и директории, имена которых оканчиваются на '. bin'. Поиск начать с '/ home/user1'*

        find /home/user1 -name "*.bin"

* найти все файлы в '/usr/bin', время последнего обращения к которым более 100 дней

        find /usr/bin -type f -atime +100

* найти все файлы в '/usr/bin', созданные или изменённые в течении последних 10 дней

        find /usr/bin -type f -mtime -10

* найти все файлы и директории, имена которых оканчиваются на '.rpm', и изменить права доступа к ним

        find / -name *.rpm -exec chmod 755 '{}' \;

* найти все файлы и директории, имена которых оканчиваются на '.rpm', игнорируя съёмные носители, такие как cdrom, floppy и т.п.

        find / -xdev -name "*.rpm"

* найти все файлы, сожержащие в имени '.ps'. Предварительно рекомендуется выполнить команду 'updatedb'

        locate "*.ps"

* показывает размещение бинарных файлов, исходных кодов и руководств, относящихся к файлу 'halt'

        whereis halt

* отображает полный путь к файлу 'halt'

        which halt

## Монтирование файловых систем

* монтирует раздел 'hda2' в точку монтирования '/mnt/hda2'. Убедитесь в наличии директории-точки монтирования '/mnt/hda2'

        mount /dev/hda2 /mnt/hda2
* размонтирует раздел 'hda2'. Перед выполнением, покиньте '/mnt/hda2'

        umount /dev/hda2
* принудительное размонтирование раздела. Применяется в случае, когда раздел занят каким-либо пользователем

        fuser -km /mnt/hda2
* выполнить размонитрование без занесения информации в /etc/mtab. Полезно когда файл имеет атрибуты «только чтение» или недостаточно места на диске

        umount -n /mnt/hda2
* монтировать флоппи-диск

        mount /dev/fd0 /mnt/floppy
* монтировать CD или DVD

        mount /dev/cdrom /mnt/cdrom
* монтировать CD-R/CD-RW или DVD-R/DVD-RW(+-)

        mount /dev/hdc /mnt/cdrecorder
* смонтировать ISO-образ

        mount -o loop file.iso /mnt/cdrom
* монтировать файловую систему Windows FAT32

        mount -t vfat /dev/hda5 /mnt/hda5
* монтировать сетевую файловую систему Windows (SMB/CIFS)

        mount -t smbfs -o username=user,password=pass //winclient/share /mnt/share
* «монтирует» директорию в директорию (binding). Доступна с версии ядра 2.4.0. Полезна, например, для предоставления содержимого пользовательской директории через ftp при работ
е ftp-сервера в «песочнице» (chroot), когда симлинки сделать невозможно. Выполнение данной команды сделает копию содержимого /home/user/prg в /var/ftp/user

        mount -o bind /home/user/prg /var/ftp/user

## Дисковое пространство

* информация о смонтированных разделах с отображением общего, доступного и используемого пространства (Прим.переводчика. ключ -h работает не во всех *nix системах)

        df -h
* вывести список файлов и директорий рекурсивно с сортировкой по возрастанию размера и осуществлять постраничный просмотр

        ls -lSr |more
* вывести размер, занимаемый директорией 'dir1' (Прим.переводчика. ключ -h работает не во всех *nix системах)

        du -sh dir1
* размер и имена файлов и директорий, с соритровкой по размеру

        du -sk * | sort -rn
* размер используемого дискового пространства, занимаемое файлами rpm-пакета, с сортировкой по размеру (fedora, redhat и т.п.)

        rpm -q -a --qf '%10t%n' | sort -k1,1n
* размер используемого дискового пространства, занимаемое файлами deb-пакета, с сортировкой по размеру (ubuntu, debian т.п.)

        dpkg-query -W -f='${Installed-Size;10}t$n' | sort -k1,1n

## Пользователи и группы

* создать новую группу с именем group_name

        groupadd group_name
* удалить группу group_name

        groupdel group_name
* переименовать группу old_group_name в new_group_name

        groupmod -n new_group_name old_group_name
* создать пользователя user1, назначить ему в качестве домашнего каталога /home/user1, в качестве shell'а /bin/bash, включить его в группу admin и добавить комментарий Nome Cognome

        useradd -c "Nome Cognome" -g admin -d /home/user1 -s /bin/bash user1
* создать пользователя user1

        useradd user1
* удалить пользователя user1 и его домашний каталог

        userdel -r user1
* изменить атрибуты пользователя

        usermod -c "User FTP" -g system -d /ftp/user1 -s /bin/nologin user1
* сменить пароль

        passwd
* сменить пароль пользователя user1 (только root)

        passwd user1
* установить дату окончания действия учётной записи пользователя user1

        chage -E 2005-12-31 user1
* проверить корректность системных файлов учётных записей. Проверяются файлы /etc/passwd и /etc/shadow

        pwck
* проверить корректность системных файлов учётных записей. Проверяется файл/etc/group

        grpck
* изменить первичную группу текущего пользователя. Если указать «-», ситуация будет идентичной той, в которой пользователь вышил из системы и снова вошёл. Если не указывать группу, первичная группа будет назначена из /etc/passwd

        newgrp [-] group_name

## Выставление/изменение полномочий на файлы

* просмотр полномочий на файлы и директории в текущей директории

        ls -lh
* вывести содержимое директории /tmp и разделить вывод на пять колонок

        ls /tmp | pr -T5 -W$COLUMNS
* добавить полномочия на директорию directory1 ugo(User Group Other)+rwx(Read Write eXecute) — всем полные права. Аналогичное можно сделать таким образом chmod 777 directory1

        chmod ugo+rwx directory1
* отобрать у группы и всех остальных все полномочия на директорию directory1

        chmod go-rwx directory1
* назначить владельцем файла file1 пользователя user1

        chown user1 file1
* назначить рекурсивно владельцем директории directory1 пользователя user1

        chown -R user1 directory1
* сменить группу-владельца файла file1 на group1

        chgrp group1 file1
* сменить владельца и группу владельца файла file1

        chown user1:group1 file1
* найти, начиная от корня, все файлы с выставленным SUID

        find / -perm -u+s
* назначить SUID-бит файлу /bin/binary_file. Это даёт возможность любому пользователю запускать на выполнение файл с полномочиями владельца файла

        chmod u+s /bin/binary_file
* снять SUID-бит с файла /bin/binary_file

        chmod u-s /bin/binary_file
* назначить SGID-бит директории /home/public

        chmod g+s /home/public
* снять SGID-бит с директории /home/public

        chmod g-s /home/public
* назначить STIKY-бит директории /home/public. Позволяет удалять файлы только владельцам

        chmod o+t /home/public
* снять STIKY-бит с директории /home/public

        chmod o-t /home/public

## Специальные атрибуты файлов

* позволить открывать файл на запись только в режиме добавления

        chattr +a file1
* позволяет ядру автоматически сжимать/разжимать содержимое файла

        chattr +c file1
* указавет утилите dump игнорировать данный файл во время выполнения backup'а

        chattr +d file1
* делает файл недоступным для любых изменений: редактирование, удаление, перемещение, создание линков на него

        chattr +i file1
* позволяет сделать удаление файла безопасным, т.е. выставленный атрибут s говорит о том, что при удалении файла, место, занимаемое файлом на диске заполняется нулями, что предотвращяет возможность восстановления данных

        chattr +s file1
* указывает, что, при сохранении изменений, будет произведена синхронизация, как при выполнении команды sync

        chattr +S file1
* данный атрибут указывает, что при удалении файла содержимое его будет сохранено и при необходимости пользователь сможет его восстановить

        chattr +u file1
* показать атрибуты файлов

        lsattr

## Архивирование и сжатие файлов

* разжать файл 'file1.bz2'

        bunzip2 file1.bz2
* разжать файл 'file1.gz'

        gunzip file1.gz
* сжать файл 'file1'

        gzip file1 или bzip2 file1
* сжать файл file1 с максимальным сжатием

        gzip -9 file1
* создать rar-архив 'file1.rar' и включить в него файл test_file

        rar a file1.rar test_file
* создать rar-архив 'file1.rar' и включить в него file1, file2 и dir1

        rar a file1.rar file1 file2 dir1
* распаковать rar-архив

        unrar x file1.rar
* создать tar-архив archive.tar, содержащий файл file1

        tar -cvf archive.tar file1
* создать tar-архив archive.tar, содержащий файл file1, file2 и dir1

        tar -cvf archive.tar file1 file2 dir1
* показать содержимое архива

        tar -tf archive.tar
* распаковать архив

        tar -xvf archive.tar
* распаковать архив в /tmp

        tar -xvf archive.tar -C /tmp
* создать архив и сжать его с помощью bzip2(Прим.переводчика. ключ -j работает не во всех *nix системах)

        tar -cvfj archive.tar.bz2 dir1
* разжать архив и распаковать его(Прим.переводчика. ключ -j работает не во всех *nix системах)

        tar -xvfj archive.tar.bz2
* создать архив и сжать его с помощью gzip

        tar -cvfz archive.tar.gz dir1
* разжать архив и распаковать его

        tar -xvfz archive.tar.gz
* создать сжатый zip-архив

        zip file1.zip file1
* создать сжатый zip-архив и со включением в него нескольких файлов и/или директорий

        zip -r file1.zip file1 file2 dir1
* разжать и распаковать zip-архив

        unzip file1.zip

## RPM пакеты (Fedora, Red Hat и тому подобное)

* установить пакет с выводом сообщений и прогресс-бара

        rpm -ivh package.rpm
* установить пакет с выводом сообщений и прогресс-бара без контроля зависимостей

        rpm -ivh --nodeps package.rpm
* обновить пакет без изменений конфигурационных файлов, в случае отсутствия пакета, он будет установлен

        rpm -U package.rpm
* обновить пакет только если он установлен

        rpm -F package.rpm
* удалить пакет

        rpm -e package_name.rpm
* отобразить список всех пакетов, установленных в системе

        rpm -qa
* среди всех пакетов, установленных в системе, найти пакет содержащий в своём имени «httpd»

        rpm -qa | grep httpd
* вывести информацию о конкрентном пакете

        rpm -qi package_name
* отобразить пакеты входящие в группу пакетов

        rpm -qg "System Environment/Daemons"
* вывести список файлов, входящих в пакет

        rpm -ql package_name
* вывести список конфигурационных файлов, входящих в пакет

        rpm -qc package_name
* вывести список пакетов, необходимых для установки конкретного пакета по зависимостям

        rpm -q package_name --whatrequires
* отобразить скрипты, запускаемые при установке/удалении пакета

        rpm -q package_name --scripts
* вывести историю ревизий пакета

        rpm -q package_name --changelog
* проверить какому пакету принадлежит указанный файл. Указывать следует полный путь и имя файла

        rpm -qf /etc/httpd/conf/httpd.conf
* отображает список файлов, входящих в пакет, но ещё не установленных в систему

        rpm -qp package.rpm -l
* ипортировать публичный ключ цифровой подписи

        rpm --import /media/cdrom/RPM-GPG-KEY
* проверит подпись пакета

        rpm --checksig package.rpm
* проверить целостность установленного содержимого пакета

        rpm -qa gpg-pubkey
* проверить размер, полномочия, тип, владельца, группу, MD5-сумму и дату последнего изменеия пакета

        rpm -V package_name
* проверить содержимое всех пакеты установленные в систему. Выполняйте с осторожностью!

        rpm -Va
* проверить пакет, который ещё не установлен в систему

        rpm -Vp package.rpm
* извлечь из пакета файлы содержащие в своём имени bin

        rpm2cpio package.rpm | cpio --extract --make-directories *bin*
* установить пакет, собранный из исходных кодов

        rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm
* собрать пакет из исходных кодов

        rpmbuild --rebuild package_name.src.rpm

## YUM — средство обновления пакетов(Fedora, RedHat и тому подобное)

* закачать и установать пакет

        yum install package_name
* обновить все пакеты, установленные в систему

        yum update
* обновить пакет

        yum update package_name
* удалить пакет

        yum remove package_name
* вывести список всех пакетов, установленных в систему

        yum list
* найти пакет в репозитории

        yum search package_name
* очисть rpm-кэш, удалив закачанные пакеты

        yum clean packages
* удалить все заголовки файлов, которые система использует для разрешения зависимостей

        yum clean headers
* очисть rpm-кэш, удалив закачанные пакеты и заголовки

        yum clean all


## DEB пакеты (Debian, Ubuntu и тому подобное)

* установить / обновить пакет

        dpkg -i package.deb
* удалить пакет из системы

        dpkg -r package_name
* показать все пакеты, установленные в систему

        dpkg -l
* среди всех пакетов, установленных в системе, найти пакет содержащий в своём имени «apache2»

        dpkg -l | | grep apache2
* отобразить инфрмацию о конкретном пакете

        dpkg -s package_name
* вывести список файлов, входящих в пакет, установленный в систему

        dpkg -L package_name
* отобразить список файлов, входящих в пакет, который ешё не установлен в систему

        dpkg --contents package.deb
* найти пакет, в который входит указанный файл

        dpkg -S /bin/ping

## APT — средство управление пакетами (Debian, Ubuntu и тому подобное)

* установить / обновить пакет

        apt-get install package_name
* установить / обновить пакет с cdrom'а

        apt-cdrom install package_name
* получить обновлённые списки пакетов

        apt-get update
* обновить пакеты, установленные в систему

        apt-get upgrade
* удалить пакет, установленный в систему с сохранением файлов конфигурации

        apt-get remove package_name
* удалить пакет, установленный в систему с удалением файлов конфигурации

        apt-get purge package_name
* проверить целостность зависимостей

        apt-get check
* удалить загруженные архивные файлы пакетов

        apt-get clean
* удалить старые загруженные архивные файлы пакетов

        apt-get autoclean

## Pacman — средство управление пакетами (Arch Linux, Chakra, Frugalware и alike)

* установить пакет из репозитория. Если после команды добавить <code>--noconfirm</code>, то не потребуется подтверждать действия.

        pacman -S package_name
* установить пакет из текущей деиректории

        pacman -U package_name
* удалить пакет

        pacman -R package_name

* удалить пакет с зависимостями, которые более не требуются

        pacman -Rs package_name
* найти пакет

        pacman -Ss package_name
* получить обновленные списки пакетов

        pacman -Sy
* обновить пакеты

        pacman -Su

## Просмотр содержимого файлов

* вывести содержимое файла file1 на стандартное устройсво вывода

        cat file1
* вывести содержимое файла file1 на стандартное устройсво вывода в обратном порядке (последняя строка становиться первой и т.д.)

        tac file1
* постраничный вывод содержимого файла file1 на стандартное устройство вывода

        more file1
* постраничный вывод содержимого файла file1 на стандартное устройство вывода, но с возможностью пролистывания в обе стороны (вверх-вниз), поиска по содержимому и т.п.

        less file1
* вывести первые две строки файла file1 на стандартное устройство вывода. По-умолчанию выводится десять строк

        head -2 file1
* вывести последние две строки файла file1 на стандартное устройство вывода. По-умолчанию выводится десять строк

        tail -2 file1
* выводить содержимое файла /var/log/messages на стандартное устройство вывода по мере появления в нём текста

        tail -f /var/log/messages

## Манипуляции с текстом

* общий синтаксис выполнения действий по обработке содержимого файла и вывода результата в новый

        cat file_originale | [operation: sed, grep, awk, grep и т.п.] > result.txt
* общий синтаксис выполнения действий по обработке содержимого файла и вывода результата в существующий файл. Если файл не существует, он будет создан

        cat file_originale | [operazione: sed, grep, awk, grepи т.п.] >> result.txt
* из файла '/var/log/messages' отобрать и вывести на стандартное устройство вывода строки, содержащие «Aug»

        grep Aug /var/log/messages
* из файла '/var/log/messages' отобрать и вывести на стандартное устройство вывода строки, начинающиеся на «Aug»

        grep ^Aug /var/log/messages
* из файла '/var/log/messages' отобрать и вывести на стандартное устройство вывода строки, содержащие цифры

        grep [0-9] /var/log/messages
* отобрать и вывести на стандартное устройство вывода строки, содержащие «Augr», во всех файлах, находящихся в директории /var/log и ниже

        grep Aug -R /var/log/*
* в файле example.txt заменить «string1» на «string2», результат вывести на стандартное устройство вывода

        sed 's/stringa1/stringa2/g' example.txt
* удалить пустые строки из файла example.txt

        sed '/^$/d' example.txt
* удалить пустые строки и комментарии из файла example.txt

        sed '/ *#/d; /^$/d' example.txt
* преобразовать символы из нижнего регистра в верхний

        echo 'esempio' | tr '[:lower:]' '[:upper:]'
* удалить первую строку из файла example.txt

        sed -e '1d' result.txt
* отобразить только строки содержашие «string1»

        sed -n '/string1/p'
* удалить пустые символы в в конце каждой строки

        sed -e 's/ *$//' example.txt
* удалить строку «string1» из текста не изменяя всего остального

        sed -e 's/string1//g' example.txt
* взять из файла с первой по восьмую строки и из них вывести первые пять

        sed -n '1,8p;5q' example.txt
* вывести пятую строку

        sed -n '5p;5q' example.txt
* заменить последовательность из любого количества нулей одним нулём

        sed -e 's/0*/0/g' example.txt
* пронумеровать строки при выводе содержимого файла

        cat -n file1
* при выводе содержимого файла, не выводить чётные строки файла

        cat example.txt | awk 'NR%2==1'
* вывести первую колонку. Разделение, по-умолчанию, по проблелу/пробелам или символу/символам табуляции

        echo a b c | awk '{print $1}'
* вывести первую и треью колонки. Разделение, по-умолчанию, по проблелу/пробелам или символу/символам табуляции

        echo a b c | awk '{print $1,$3}'
* объединить содержимое file1 и file2 в виде таблицы: строка 1 из file1 = строка 1 колонка 1-n, строка 1 из file2 = строка 1 колонка n+1-m

        paste file1 file2
* объединить содержимое file1 и file2 в виде таблицы с разделителем «+»

        paste -d '+' file1 file2
* отсортировать содержимое двух файлов

        sort file1 file2
* отсортировать содержимое двух файлов, не отображая повторов

        sort file1 file2 | uniq
* отсортировать содержимое двух файлов, отображая только уникальные строки (строки, встречающиеся в обоих файлах, не выводятся на стандартное устройство вывода)

        sort file1 file2 | uniq -u
* отсортировать содержимое двух файлов, отображая только повторяющиеся строки

        sort file1 file2 | uniq -d
* сравнить содержимое двух файлов, не отображая строки принадлежащие файлу 'file1'

        comm -1 file1 file2
* сравнить содержимое двух файлов, не отображая строки принадлежащие файлу 'file2'

        comm -2 file1 file2
* сравнить содержимое двух файлов, удаляя строки встречающиеся в обоих файлах

        comm -3 file1 file2

## Преобразование наборов символов и файловых форматов

* конвертировать файл текстового формата из MSDOS в UNIX (разница в символах возврата коретки)

        dos2unix filedos.txt fileunix.txt
* конвертировать файл текстового формата из UNIX в MSDOS (разница в символах возврата коретки)

        unix2dos fileunix.txt filedos.txt
* конвертировать содержимое тестового файла page.txt в html-файл page.html

        recode ..HTML < page.txt > page.html
* вывести список доступных форматов

        recode -l | more

## Анализ файловых систем

* проверить раздел hda1 на наличие bad-блоков

        badblocks -v /dev/hda1
* проверить/восстановить целостность linux-файловой системы раздела hda1

        fsck /dev/hda1
* проверить/восстановить целостность файловой системы ext2 раздела hda1

        fsck.ext2 /dev/hda1 или e2fsck /dev/hda1
* проверить/восстановить целостность файловой системы ext3 раздела hda1 с указанием, что журнал расположен там же

        e2fsck -j /dev/hda1
* проверить/восстановить целостность файловой системы ext3 раздела hda1

        fsck.ext3 /dev/hda1
* проверить/восстановить целостность файловой системы fat раздела hda11

        fsck.vfat /dev/hda1

## Форматирование файловых систем

* создать linux-файловую систему на разделе hda1

        mkfs /dev/hda1
* создать файловую систему ext2 на разделе hda1

        mke2fs /dev/hda1
* создать журналирующую файловую систему ext3 на разделе hda1

        mke2fs -j /dev/hda1
* создать файловую систему FAT32 на разделе hda1

        mkfs -t vfat 32 -F /dev/hda1
* форматирование флоппи-диска без проверки

        fdformat -n /dev/fd0
* создание swap-пространства на разделе hda3

        mkswap /dev/hda3

## swap-пространство

* создание swap-пространства на разделе hda3

        mkswap /dev/hda3
* активировать swap-пространство, расположенное на разделе hda3

        swapon /dev/hda3
* активировать swap-пространства, расположенные на разделах hda2 и hdb3

        swapon /dev/hda2 /dev/hdb3

## Создание резервных копий (backup)

* создать полную резервную копию директории /home в файл /tmp/home0.bak

        dump -0aj -f /tmp/home0.bak /home
* создать инкрементальную резервную копию директории /home в файл 

        dump -1aj -f /tmp/home0.bak /home
* восстановить из резервной копии /tmp/home0.bak

        restore -if /tmp/home0.bak
* синхронизировать /tmp с /home

        rsync -rogpav --delete /home /tmp
* синхронизировать через SSH-туннель

        rsync -rogpav -e ssh --delete /home ip_address:/tmp
* синхронизировать локальную директорию с удалённой директорией через ssh-туннель со сжатием

        rsync -az -e ssh --delete ip_addr:/home/public /home/local
* синхронизировать удалённую директорию с локальной директорией через ssh-туннель со сжатием

        rsync -az -e ssh --delete /home/local ip_addr:/home/public
* сделать «слепок» локального диска в файл на удалённом компьютере через ssh-туннель

        dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz'
* создать инкрементальную резервную копию директории '/home/user' в файл backup.tar с сохранением полномочий

        tar -Puf backup.tar /home/user
* копирование содержимого /tmp/local на удалённый компьютер через ssh-туннель в /home/share/

        ( cd /tmp/local/ && tar c . ) | ssh -C user@ip_addr 'cd /home/share/ && tar x -p'
* копирование содержимого /home на удалённый компьютер через ssh-туннель в /home/backup-home

        ( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home && tar x -p'
* копирование одной директории в другую с сохранением полномочий и линков

        tar cf - . | (cd /tmp/backup ; tar xf - )
* поиск в /home/user1 всех файлов, имена которых оканчиваются на '.txt', и копирование их в другую директорию

        find /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents
* поиск в /var/log всех файлов, имена которых оканчиваются на '.log', и создание bzip-архива из них

        find /var/log -name '*.log' | tar cv --files-from=- | bzip2 > log.tar.bz2
* создать копию MBR (Master Boot Record) с /dev/hda на флоппи-диск

        dd if=/dev/hda of=/dev/fd0 bs=512 count=1
* восстановить MBR с флоппи-диска на /dev/hda

        dd if=/dev/fd0 of=/dev/hda bs=512 count=1

## Сеть

* показать конфигурацию сетевого интерфейса eth0

        ifconfig eth0
* активировать (поднять) интерфейс eth0

        ifup eth0
* деактивировать (опустить) интерфейс eth0

        ifdown eth0
* выставить интерфейсу eth0 ip-адрес и маску подсети

        ifconfig eth0 192.168.1.1 netmask 255.255.255.0
* перевести интерфейс eth0 в promiscuous-режим для «отлова» пакетов (sniffing)

        ifconfig eth0 promisc
* отключить promiscuous-режим на интерфейсе eth0

        ifconfig eth0 -promisc
* активировать интерфейс eth0 в dhcp-режиме.

        dhclient eth0
* вывести локальную таблицу маршрутизации

        route -n
* задать ip-адрес шлюза по умолчанию (default gateway)

        route add -net 0/0 gw IP_Gateway 
* добавить статический маршрут в сеть 192.168.0.0/16 через шлюз с ip-адресом 192.168.1.1

        route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1
* удалить ip-адрес шлюза по умолчанию (default gateway)

        route del 0/0 gw IP_gateway
* разрешить пересылку пакетов (forwarding)

        echo "1" > /proc/sys/net/ipv4/ip_forward
* отобразить имя компьютера

        hostname
* разрешить имя http://www.linuxguide.it хоста в ip-адрес и наоборот

        host http://www.linuxguide.it
* отобразить состояние всех интерфейсов

        ip link show
* отобразить статус и тип соединения для интерфейса eth0

        mii-tool eth0
* отображает статистику интерфеса eth0 с выводом такой информации, как поддерживаемые и текущие режимы соединения

        ethtool eth0
* отображает все установленные сетевые соединения по протоколам TCP и UDP без разрешения имён в ip-адреса и PID'ы и имена процессов, обеспечивающих эти соединения

        netstat -tupn
* отображает все сетевые соединения по протоколам TCP и UDP без разрешения имён в ip-адреса и PID'ы и имена процессов, слушающих порты

        netstat -tupln
* отобразить весь трафик на TCP-порт 80 (обычно — HTTP)

        tcpdump tcp port 80
* просканировать эфир на предмет, доступности беспроводных точек доступа

        iwlist scan
* показать конфигурацию беспроводного сетевого интерфейса eth1

        iwconfig eth1

## Microsoft Windows networks(SAMBA)

* разрешить netbios-имя nbtscan не во всех системах ставится по-умолчанию, возможно, придётся доустанавливать вручную. nmblookup включен в пакет samba

        nmblookup -A ip_addr
* отобразить ресурсы, предоставленные в общий доступ на windows-машине

        smbclient -L ip_addr/hostname
* подобно wget может получить файлы с windows-машин через smb-протокол

        smbget -Rr smb://ip_addr/share
* смонтировать smb-ресурс, предоставленный на windows-машине, в локальную файловую систему

        mount -t smbfs -o username=user,password=pass //winclient/share /mnt/share

## IPTABLES (firewall)

* отобразить все цепочки правил

        iptables -nL
* отобразить все цепочки правил в NAT-таблице

        iptables -t nat -L
* очистить все цепочки правил в filter-таблице

        iptables -t filter -F
* очистить все цепочки правил в NAT-таблице

        iptables -t nat -F
* удалить все пользовательские цепочки правил в filter-таблице

        iptables -t filter -X
* позволить входящее подключение telnet'ом

        iptables -t filter -A INPUT -p tcp --dport telnet -j ACCEPT
* блокировать исходящие HTTP-соединения

        iptables -t filter -A OUTPUT -p tcp --dport http -j DROP
* позволить «прокидывать» (forward) POP3-соединения

        iptables -t filter -A FORWARD -p tcp --dport pop3 -j ACCEPT
* включить журналирование ядром пакетов, проходящих через цепочку INPUT, и добавлением к сообщению префикса «DROP INPUT»

        iptables -t filter -A INPUT -j LOG --log-prefix "DROP INPUT"
* включить NAT (Network Address Translate) исходящих пакетов на интерфейс eth0. Допустимо при использовании с динамически выделяемыми ip-адресами

        iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
* перенаправление пакетов, адресованных одному хосту, на другой хост

        iptables -t nat -A PREROUTING -d 192.168.0.1 -p tcp -m tcp --dport 22 -j DNAT --to-destination 10.0.0.2:22

## Мониторинг и отладка

* отобразить запущенные процессы, используемые ими ресурсы и другую полезную информацию (с автоматическим обновлением данных)

        top
* отобразить запущенные процессы, используемые ими ресурсы и другую полезную информацию (единожды)

        ps -eafw
* вывести PID'ы и процессы в виде дерева

        ps -e -o pid,args --forest
* отобразить дерево процессов

        pstree
* «убить» процесс с PID 98989 «на смерть» (без соблюдения целостности данных)

        kill -9 98989 или kill -KILL 98989
* корректно завершить процесс с PID 98989

        kill -TERM 98989
* заставить процесс с PID 98989 перепрочитать файл конфигурации

        kill -1 98989 или kill -HUP 98989
* отобразить список файлов, открытых процессом с PID 98989

        lsof -p 98989
* отобразить список открытых файлов из директории /home/user1

        lsof /home/user1
* вывести список системных вызовов, созданных и полученных процессом ls

        strace -c ls >/dev/null
* вывести вызовы бибилотек

        strace -f -e open ls >/dev/null
* отображать прерывания в режиме реального времени

        watch -n1 'cat /proc/interrupts'
* отобразить историю перезагрузок системы

        last reboot
* отобразить историю регистрации пользователя user1 в системе и время его нахождения в ней

        last user1
* вывести загруженные модули ядра

        lsmod
* показать состояние оперативной памяти в мегабайтах

        free -m
* контроль состояния жёсткого диска /dev/hda через SMART

        smartctl -A /dev/hda
* проверить доступность SMART на жёстком диске /dev/hda

        smartctl -i /dev/hda
* вывести десять последних записей из журнала загрузки ядра

        tail /var/log/dmesg
* вывести десять последних записей из системного журнала

        tail /var/log/messages

## Другие полезные команды

* вывести список комманд, которые так или иначе относятся к ключевым словам. Полезно, когда вы знаете что делает программа, но не помните команду

        apropos …keyword
* вызов руководства по работе с программой, в данном случае, — ping


        man ping
* отображает описание действий указанной программы

        whatis …keyword
* создаёт загрузочный флоппи-диск

        mkbootdisk --device /dev/fd0 `uname -r`
* зашифровать файл file1 с помощью GNU Privacy Guard

        gpg -c file1
* дешифровать файл file1 с помощью GNU Privacy Guard

        gpg file1.gpg
* загружает рекурсивно содержимое сайта http://www.example.com

        wget -r http://www.example.com
* загрузить файл http://www.example.com/file.iso с возможностью останова и продолжения в последствии

        wget -c http://www.example.com/file.iso
* начать закачку в указанное время

        echo 'wget -c http://www.example.com/files.iso' | at 09:00
* вывести список библиотек, необходимых для работы ssh

        ldd /usr/bin/ssh
* назначить алиас hh команде history

        alias hh='history'
